//+++++++++++++++++++++++++++++++++++++++++++++++++++++
// File automatically generated by Jfuzzy - DO NOT EDIT
//+++++++++++++++++++++++++++++++++++++++++++++++++++++

package pkg;

import xfuzzy.lang.*;

public class xfl_mf_slope extends ParamMemFunc {
 public xfl_mf_slope() {
   super.parameter = new Parameter[2];
   super.parameter[0] = new Parameter("a");
   super.parameter[1] = new Parameter("m");
   super.name = "slope";
   super.pkg = "xfl";
  }

 public double compute(double x) {
   double a = parameter[0].value;
   double m = parameter[1].value;
   double out = m*(x-a);
   return (out>1 ? 1 : (out<0 ? 0 : out));
  }

 public double greatereq(double x) {
   double min = this.u.min();
   double a = parameter[0].value;
   double m = parameter[1].value;
   double out;
   if(m>0) out = m*(x-a); else out = m*(min-a);
   return (out>1 ? 1 : (out<0 ? 0 : out));
  }

 public double smallereq(double x) {
   double max = this.u.max();
   double a = parameter[0].value;
   double m = parameter[1].value;
   double out;
   if(m>0) out = m*(max-a); else out = m*(x-a);
   return (out>1 ? 1 : (out<0 ? 0 : out));
  }

 public double[] deriv_eq(double x) {
   double[] deriv = new double[2];
   double a = parameter[0].value;
   double m = parameter[1].value;
   if(x<a && x>a+1/m) { deriv[0] = -m; deriv[1] = (x-a); }
   else if(x>a && x<a+1/m) { deriv[0] = -m; deriv[1] = (x-a); }
   else if(x==a) { deriv[0] = -m/2; deriv[1] = 0; }
   else if(x==a+1/m) { deriv[0] = -m/2; deriv[1] = 0.5/m; }
   else {  deriv[0] = 0; deriv[1] = 0; }
   return deriv;
  }

 public double[] deriv_greq(double x) {
   double[] deriv = new double[2];
   double min = this.u.min();
   double a = parameter[0].value;
   double m = parameter[1].value;
   if(m>0) {
    if(x>a && x<a+1/m) { deriv[0] = -m; deriv[1] = (x-a); }
    else if(x==a) { deriv[0] = -m/2; deriv[1] = 0; }
    else if(x==a+1/m) { deriv[0] = -m/2; deriv[1] = 0.5/m; }
    else { deriv[0] = 0; deriv[1] = 0; }
   }
   else if( m*(min-a) <1 ) { deriv[0] = -m; deriv[1] = min-a; }
   else { deriv[0] = 0; deriv[1] = 0; }
   return deriv;
  }

 public double[] deriv_smeq(double x) {
   double[] deriv = new double[2];
   double max = this.u.max();
   double a = parameter[0].value;
   double m = parameter[1].value;
   if(m<0) {
    if(x<a && x>a+1/m) { deriv[0] = -m; deriv[1] = (x-a); }
    else if(x==a) { deriv[0] = -m/2; deriv[1] = 0; }
    else if(x==a+1/m) { deriv[0] = -m/2; deriv[1] = 0.5/m; }
    else { deriv[0] = 0; deriv[1] = 0; }
   }
   else if( m*(max-a) <1 ) { deriv[0] = -m; deriv[1] = max-a; }
   else { deriv[0] = 0; deriv[1] = 0; }
   return deriv;
  }

 public boolean test () {
   double min = this.u.min();
   double max = this.u.max();
   double a = parameter[0].value;
   double m = parameter[1].value;
   return ( a>=min && a<=max );
  }

 public String toJava() {
   String eol = System.getProperty("line.separator", "\n");
   String code = "";
   code += "  private class MF_xfl_slope extends InnerMembershipFunction {"+eol;
   code += "   double a;"+eol;
   code += "   double m;"+eol;
   code += eol+"   MF_xfl_slope( double min, double max, double step, double param[]){"+eol;
   code += "    super.min = min;"+eol;
   code += "    super.max = max;"+eol;
   code += "    super.step = step;"+eol;
   code += "    this.a = param[0];"+eol;
   code += "    this.m = param[1];"+eol;
   code += "   }"+eol;
   code += "   double param(int _i) {"+eol;
   code += "    switch(_i) {"+eol;
   code += "     case 0: return a;"+eol;
   code += "     case 1: return m;"+eol;
   code += "     default: return 0;"+eol;
   code += "    }"+eol;
   code += "   }"+eol;
   code += "   double isEqual(double x) {"+eol;
   code += "      double out = m*(x-a);"+eol;
   code += "      return (out>1 ? 1 : (out<0 ? 0 : out));"+eol;
   code += "   }"+eol;
   code += "   double isGreaterOrEqual(double x) {"+eol;
   code += "      double out;"+eol;
   code += "      if(m>0) out = m*(x-a); else out = m*(min-a);"+eol;
   code += "      return (out>1 ? 1 : (out<0 ? 0 : out));"+eol;
   code += "   }"+eol;
   code += "   double isSmallerOrEqual(double x) {"+eol;
   code += "      double out;"+eol;
   code += "      if(m>0) out = m*(max-a); else out = m*(x-a);"+eol;
   code += "      return (out>1 ? 1 : (out<0 ? 0 : out));"+eol;
   code += "   }"+eol;
   code += "  }"+eol;
   return code;
  }

 public String toC() {
   String eol = System.getProperty("line.separator", "\n");
   String code = "";
   code += "static double MF_xfl_slope_equal(MembershipFunction _mf,double x) {"+eol;
   code += " double a = _mf.param[0];"+eol;
   code += " double m = _mf.param[1];"+eol;
   code += "    double out = m*(x-a);"+eol;
   code += "    return (out>1 ? 1 : (out<0 ? 0 : out));"+eol;
   code += "}"+eol;
   code += "static double MF_xfl_slope_greq(MembershipFunction _mf,double x) {"+eol;
   code += " double min = _mf.min;"+eol;
   code += " double a = _mf.param[0];"+eol;
   code += " double m = _mf.param[1];"+eol;
   code += "    double out;"+eol;
   code += "    if(m>0) out = m*(x-a); else out = m*(min-a);"+eol;
   code += "    return (out>1 ? 1 : (out<0 ? 0 : out));"+eol;
   code += "}"+eol;
   code += "static double MF_xfl_slope_smeq(MembershipFunction _mf,double x) {"+eol;
   code += " double max = _mf.max;"+eol;
   code += " double a = _mf.param[0];"+eol;
   code += " double m = _mf.param[1];"+eol;
   code += "    double out;"+eol;
   code += "    if(m>0) out = m*(max-a); else out = m*(x-a);"+eol;
   code += "    return (out>1 ? 1 : (out<0 ? 0 : out));"+eol;
   code += "}"+eol;
   code += "static MembershipFunction createMF_xfl_slope( double min, double max, double step, double *param,int length) {"+eol;
   code += " int i;"+eol;
   code += " MembershipFunction _mf;"+eol;
   code += " _mf.min = min;"+eol;
   code += " _mf.max = max;"+eol;
   code += " _mf.step = step;"+eol;
   code += " _mf.param = (double*) malloc(length*sizeof(double));"+eol;
   code += " for(i=0;i<length;i++) _mf.param[i] = param[i];"+eol;
   code += " _mf.compute_eq = MF_xfl_slope_equal;"+eol;
   code += " _mf.compute_greq = MF_xfl_slope_greq;"+eol;
   code += " _mf.compute_smeq = MF_xfl_slope_smeq;"+eol;
   code += " _mf.center = _defaultMFcenter;"+eol;
   code += " _mf.basis = _defaultMFbasis;"+eol;
   code += " return _mf;"+eol;
   code += "}"+eol;
   return code;
  }
 public String toCpp(String name) {
   String eol = System.getProperty("line.separator", "\n");
   String code = "";
   code += name+"::"+name+"(double min,double max,double step,double *param, int length) :"+eol;
   code += "ParamMembershipFunction(min,max,step) {"+eol;
   code += " this->name = \""+name+"\";"+eol;
   code += " this->a = param[0];"+eol;
   code += " this->m = param[1];"+eol;
   code += "}"+eol+eol;
   code += name+" * "+name+"::dup() {"+eol;
   code += " double param[2] = {a,m};"+eol;
   code += " return new "+name+"(min,max,step,param,2);"+eol;
   code += "}"+eol+eol;
   code += "double "+name+"::param(int _i) {"+eol;
   code += " switch(_i) {"+eol;
   code += "  case 0: return a;"+eol;
   code += "  case 1: return m;"+eol;
   code += "  default: return 0;"+eol;
   code += " }"+eol;
   code += "}"+eol+eol;
   code += "double "+name+"::compute_eq(double x) {"+eol;
   code += "    double out = m*(x-a);"+eol;
   code += "    return (out>1 ? 1 : (out<0 ? 0 : out));"+eol;
   code += "}"+eol+eol;
   code += "double "+name+"::compute_greq(double x) {"+eol;
   code += "    double out;"+eol;
   code += "    if(m>0) out = m*(x-a); else out = m*(min-a);"+eol;
   code += "    return (out>1 ? 1 : (out<0 ? 0 : out));"+eol;
   code += "}"+eol+eol;
   code += "double "+name+"::compute_smeq(double x) {"+eol;
   code += "    double out;"+eol;
   code += "    if(m>0) out = m*(max-a); else out = m*(x-a);"+eol;
   code += "    return (out>1 ? 1 : (out<0 ? 0 : out));"+eol;
   code += "}"+eol+eol;
   return code;
  }

 public String toHpp(String name) {
   String eol = System.getProperty("line.separator", "\n");
   String code = "";
   code += "class "+name+": public ParamMembershipFunction {"+eol;
   code += "private:"+eol;
   code += " double a;"+eol;
   code += " double m;"+eol;
   code += eol+"public:"+eol;
   code += " "+name+"() {};"+eol;
   code += " virtual ~"+name+"() {};"+eol;
   code += " "+name+"(double min,double max,double step,double *param, int length);"+eol;
   code += " "+name+"*dup();"+eol;
   code += " virtual double param(int _i);"+eol;
   code += " virtual double compute_eq(double x);"+eol;
   code += " virtual double compute_greq(double x);"+eol;
   code += " virtual double compute_smeq(double x);"+eol;
   code += "};"+eol+eol;
   return code;
  }

//+++++++++++++++++++++++++++++++++++++++++++++++++
 public void update() {
  if(!isAdjustable()) return;
  double[] prevvalue = get();
  double[] desp = getDesp();
  boolean[] adj = getAdjustable();

  double a = prevvalue[0] + desp[0];
  double b = prevvalue[1] + desp[1];
  double min = this.u.min();
  double max = this.u.max();

  if(a<min) a = min;
  if(a>max) a = max;
  if(b/prevvalue[1]<=0) b = prevvalue[1]/2;

  parameter[0].value = a;
  parameter[0].setDesp(0.0);
  parameter[0].setPrevDesp(parameter[0].value - prevvalue[0]);

  parameter[1].value = b;
  parameter[1].setDesp(0.0);
  parameter[1].setPrevDesp(parameter[1].value - prevvalue[1]);
 }
//+++++++++++++++++++++++++++++++++++++++++++++++++
}
