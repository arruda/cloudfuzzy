/* Generated By:JavaCC: Do not edit this line. PkgParser.java */
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//		PARSER DE LOS PAQUETES DE FUNCIONES		//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//

package xfuzzy.lang;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Vector;

import xfuzzy.Xfuzzy;

public class PkgParser implements PkgParserConstants {
 private final int JAVABLOCK = 0;
 private final int DERIVBLOCK = 1;
 private final int ANSICBLOCK = 2;
 private final int CPPBLOCK = 3;

 private String eol = System.getProperty("line.separator", "\n");
 private Vector path;
 private int error;
 private String errorMsg;
 private boolean end;

 public PkgParser() {
  this.path = new Vector();
  this.error = 0;
  this.errorMsg = "";
  defaultPath();
 }

 public PkgParser(File path[]) {
  this();
  for(int i=0; i<path.length; i++) this.path.addElement(path[i]);
 }

 public PkgParser(File path) {
  this();
  this.path.addElement(path);
 }

 public PkgParser(String dir) {
  this();
  File file = new File(dir);
  if(file.isDirectory()) this.path.addElement(path);
 }

 public void setPath(File path) {
  this.path = new Vector();
  this.path.addElement(path);
 }

 public void setPath(File path[]) {
  this.path = new Vector();
  for(int i=0; i<path.length; i++) this.path.addElement(path[i]);
 }

 public void addPath(File path) {
  this.path.addElement(path);
 }

 public XflPackage parse(String pkgname) {
  String filename = pkgname+".pkg";
  for(int i=0; i<path.size(); i++) {
   File dir = (File) this.path.elementAt(i);
   File file = new File(dir,filename);
   if(file.exists()) return parse(file);
  }
  return null;
 }

 public XflPackage parse(File file) {
  this.error = 0;
  this.errorMsg = "";
  XflPackage pkgdef = new XflPackage(file);
  String filename = file.getAbsolutePath();
  InputStream stream;
  try { stream = new FileInputStream(file); }
  catch (Exception e) {
   this.errorMsg += "Can't open file"+filename+eol;
   this.error++;
   return null;
  }

  initParse(stream);
  try { xflpackage(pkgdef); }
  catch (ParseException e) {
   this.errorMsg += "Fatal error loading "+filename+eol;
   this.error ++;
   return null;
  }
  catch (TokenMgrError e) {
   this.errorMsg += "Fatal error loading "+filename+eol;
   this.error ++;
   return null;
  }

  try { stream.close(); } catch (IOException e) {}

  if(this.error>0) return null;
  return pkgdef;
 }

 public String resume() {
  String msg = this.errorMsg + this.error;
  if(this.error == 1) msg += " error."; else msg += " errors.";
  return msg+eol;
 }

 public static void main(String args[]) throws Exception {
  if(args.length != 1) return;
  PkgParser parser = new PkgParser();
  XflPackage pkgdef = parser.parse(new File(args[0]));
  if(pkgdef == null) System.out.println(parser.resume());
  else if(!pkgdef.compile()) System.out.println(pkgdef.resume());
 }

 private void defaultPath() {
  File userdir = new File(System.getProperty("user.dir"));
  File pkgdir = new File( Xfuzzy.fuzzyPath +"/pkg" );
  path.addElement(userdir);
  path.addElement(pkgdir);
 }

 private void initParse(InputStream stream) {
  jj_input_stream = new ASCII_CharStream(stream, 1, 1);
  token_source = new PkgParserTokenManager(jj_input_stream);
  token = new Token();
  jj_ntk = -1;
  jj_gen = 0;
  for (int i = 0; i < jj_la1.length ; i++) jj_la1[i] = -1;
 }

 private String trim(String code) {
  String line,rest;
  int index;

  index = code.indexOf("\n"); if(index == -1) return code;
  line = code.substring(0,index);
  if(line.trim().length() == 0) rest = code.substring(index+1);
  else rest = new String(code);
  index = rest.lastIndexOf("\n"); if(index == -1) return rest;
  line = rest.substring(index);
  if(line.trim().length() == 0) rest = rest.substring(0,index);
  return rest;
 }

 private void exception(ParseException e) {
  Token t = e.currentToken.next;
  this.error ++;
  this.errorMsg += "XflPackage ["+this.error+"]. ";
  this.errorMsg += "Parse error at line "+t.beginLine+" : ";
  this.errorMsg += "Encountered \""+t.image+"\""+" while expecting ";

  int expected[] = new int[e.expectedTokenSequences.length];
  for(int i=0; i<expected.length; i++)
   expected[i] = e.expectedTokenSequences[i][0];
  if(expected.length == 1) this.errorMsg += e.tokenImage[expected[0]]+"."+eol;
  else {
   this.errorMsg += "one of :"+e.tokenImage[expected[0]];
   for(int i=1; i<expected.length; i++)
    this.errorMsg += ", "+e.tokenImage[expected[i]];
   this.errorMsg += "."+eol;
  }
 }

 private void exception(TokenMgrError e) {
  this.error ++;
  this.errorMsg += "XflPackage ["+this.error+"]. "+e.getMessage()+eol;
 }

  final public void tryDefinition(XflPackage pkg) throws ParseException {
    try {
      definition(pkg);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void definition(XflPackage pkg) throws ParseException {
        Definition def;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BINARY:
      def = binarydef(pkg);
                         pkg.add(def,XflPackage.BINARY);
      break;
    case UNARY:
      def = unarydef(pkg);
                        pkg.add(def,XflPackage.UNARY);
      break;
    case MF:
      def = mfdef(pkg);
                        pkg.add(def,XflPackage.MFUNC);
      break;
    case DEFUZ:
      def = defuzdef(pkg);
                        pkg.add(def,XflPackage.DEFUZ);
      break;
    case 0:
      jj_consume_token(0);
          end = true;
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public Definition binarydef(XflPackage pkg) throws ParseException {
        Definition def;
        Token tid;
    jj_consume_token(BINARY);
    tid = jj_consume_token(ID);
    def = Definition.createBinaryDefinition(pkg.toString(), tid.image);
    jj_consume_token(31);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALIAS:
        tryAliasBlock(def);
        break;
      case PARAM:
        tryParamBlock(def);
        break;
      case REQUIRES:
        tryRequiresBlock(def);
        break;
      case JAVA:
        tryJavaBlock(def);
        break;
      case ANSI_C:
        tryCBlock(def);
        break;
      case CPLUSPLUS:
        tryCppBlock(def);
        break;
      case DERIVATIVE:
        tryDerivativeBlock(def);
        break;
      case SOURCE:
        tryOtherBlock(def);
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALIAS:
      case PARAM:
      case JAVA:
      case ANSI_C:
      case CPLUSPLUS:
      case DERIVATIVE:
      case REQUIRES:
      case SOURCE:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_1;
      }
    }
    jj_consume_token(32);
         {if (true) return def;}
    throw new Error("Missing return statement in function");
  }

  final public Definition unarydef(XflPackage pkg) throws ParseException {
        Definition def;
        Token tid;
    jj_consume_token(UNARY);
    tid = jj_consume_token(ID);
         def = Definition.createUnaryDefinition(pkg.toString(), tid.image);
    jj_consume_token(31);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALIAS:
        tryAliasBlock(def);
        break;
      case PARAM:
        tryParamBlock(def);
        break;
      case REQUIRES:
        tryRequiresBlock(def);
        break;
      case JAVA:
        tryJavaBlock(def);
        break;
      case ANSI_C:
        tryCBlock(def);
        break;
      case CPLUSPLUS:
        tryCppBlock(def);
        break;
      case DERIVATIVE:
        tryDerivativeBlock(def);
        break;
      case SOURCE:
        tryOtherBlock(def);
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALIAS:
      case PARAM:
      case JAVA:
      case ANSI_C:
      case CPLUSPLUS:
      case DERIVATIVE:
      case REQUIRES:
      case SOURCE:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_2;
      }
    }
    jj_consume_token(32);
         {if (true) return def;}
    throw new Error("Missing return statement in function");
  }

  final public Definition defuzdef(XflPackage pkg) throws ParseException {
        Definition def;
        Token tid;
    jj_consume_token(DEFUZ);
    tid = jj_consume_token(ID);
         def = Definition.createDefuzDefinition(pkg.toString(), tid.image);
    jj_consume_token(31);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALIAS:
        tryAliasBlock(def);
        break;
      case PARAM:
        tryParamBlock(def);
        break;
      case REQUIRES:
        tryRequiresBlock(def);
        break;
      case SOURCE:
        tryOtherBlock(def);
        break;
      case DEFINED:
        tryDefineBlock(def);
        break;
      case JAVA:
        tryJavaBlock(def);
        break;
      case ANSI_C:
        tryCBlock(def);
        break;
      case CPLUSPLUS:
        tryCppBlock(def);
        break;
      case DERIVATIVE:
        tryDerivativeBlock(def);
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALIAS:
      case PARAM:
      case DEFINED:
      case JAVA:
      case ANSI_C:
      case CPLUSPLUS:
      case DERIVATIVE:
      case REQUIRES:
      case SOURCE:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_3;
      }
    }
    jj_consume_token(32);
         {if (true) return def;}
    throw new Error("Missing return statement in function");
  }

  final public Definition mfdef(XflPackage pkg) throws ParseException {
        Definition def;
        Token tid;
    jj_consume_token(MF);
    tid = jj_consume_token(ID);
         def = Definition.createMFDefinition(pkg.toString(), tid.image);
    jj_consume_token(31);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALIAS:
        tryAliasBlock(def);
        break;
      case PARAM:
        tryParamBlock(def);
        break;
      case REQUIRES:
        tryRequiresBlock(def);
        break;
      case SOURCE:
        tryOtherBlock(def);
        break;
      case JAVA:
        tryMFJavaBlock(def);
        break;
      case ANSI_C:
        tryMFAnsiCBlock(def);
        break;
      case CPLUSPLUS:
        tryMFCppBlock(def);
        break;
      case DERIVATIVE:
        tryMFDerivativeBlock(def);
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALIAS:
      case PARAM:
      case JAVA:
      case ANSI_C:
      case CPLUSPLUS:
      case DERIVATIVE:
      case REQUIRES:
      case SOURCE:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_4;
      }
    }
    jj_consume_token(32);
         {if (true) return def;}
    throw new Error("Missing return statement in function");
  }

  final public void tryAliasBlock(Definition def) throws ParseException {
    try {
      aliasblock(def);
    } catch (ParseException e) {
                            exception(e); skipto(";");
    } catch (TokenMgrError e) {
                           exception(e); skipto(";");
    }
  }

  final public void aliasblock(Definition def) throws ParseException {
        Vector vector = new Vector();
        Token tid;
    jj_consume_token(ALIAS);
    tid = jj_consume_token(ID);
                    vector.addElement( tid.image );
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 33:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_5;
      }
      jj_consume_token(33);
      tid = jj_consume_token(ID);
                   vector.addElement( tid.image );
    }
    jj_consume_token(34);
         def.setAlias(vector);
  }

  final public void tryParamBlock(Definition def) throws ParseException {
    try {
      paramblock(def);
    } catch (ParseException e) {
                            exception(e); skipto(";");
    } catch (TokenMgrError e) {
                           exception(e); skipto(";");
    }
  }

  final public void paramblock(Definition def) throws ParseException {
        Vector vector = new Vector();
        Token tid;
    jj_consume_token(PARAM);
    tid = jj_consume_token(ID);
                    vector.addElement( tid.image );
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 33:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_6;
      }
      jj_consume_token(33);
      tid = jj_consume_token(ID);
                   vector.addElement( tid.image );
    }
    jj_consume_token(34);
         def.setParameters(vector);
  }

  final public void tryRequiresBlock(Definition def) throws ParseException {
    try {
      requiresblock(def);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void requiresblock(Definition def) throws ParseException {
        String code;
    jj_consume_token(REQUIRES);
    jj_consume_token(31);
    code = codeblock();
    jj_consume_token(RBRACE);
         def.setCode(Definition.REQUIREMENTS,trim(code));
  }

  final public void tryOtherBlock(Definition def) throws ParseException {
    try {
      otherblock(def);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void otherblock(Definition def) throws ParseException {
        String code;
    jj_consume_token(SOURCE);
    jj_consume_token(31);
    code = codeblock();
    jj_consume_token(RBRACE);
         def.setCode(Definition.SOURCE,trim(code));
  }

  final public void tryDefineBlock(Definition def) throws ParseException {
    try {
      defineblock(def);
    } catch (ParseException e) {
                            exception(e); skipto(";");
    } catch (TokenMgrError e) {
                           exception(e); skipto(";");
    }
  }

  final public void defineblock(Definition def) throws ParseException {
        Vector vector = new Vector();
        Token tid;
    jj_consume_token(DEFINED);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPERATOR:
      tid = jj_consume_token(OPERATOR);
      break;
    case ID:
      tid = jj_consume_token(ID);
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                         vector.addElement( tid.image );
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 33:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_7;
      }
      jj_consume_token(33);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPERATOR:
        tid = jj_consume_token(OPERATOR);
        break;
      case ID:
        tid = jj_consume_token(ID);
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                    vector.addElement( tid.image );
    }
    jj_consume_token(34);
         def.setDefinedFor(vector);
  }

  final public void tryJavaBlock(Definition def) throws ParseException {
    try {
      javablock(def);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void javablock(Definition def) throws ParseException {
        String code;
    jj_consume_token(JAVA);
    jj_consume_token(31);
    code = codeblock();
    jj_consume_token(RBRACE);
         def.setCode(Definition.JAVA_EQUAL, trim(code));
  }

  final public void tryCBlock(Definition def) throws ParseException {
    try {
      cblock(def);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void cblock(Definition def) throws ParseException {
        String code;
    jj_consume_token(ANSI_C);
    jj_consume_token(31);
    code = codeblock();
    jj_consume_token(RBRACE);
         def.setCode(Definition.C_EQUAL, trim(code));
  }

  final public void tryCppBlock(Definition def) throws ParseException {
    try {
      cppblock(def);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void cppblock(Definition def) throws ParseException {
        String code;
    jj_consume_token(CPLUSPLUS);
    jj_consume_token(31);
    code = codeblock();
    jj_consume_token(RBRACE);
         def.setCode(Definition.CPP_EQUAL, trim(code));
  }

  final public void tryDerivativeBlock(Definition def) throws ParseException {
    try {
      derivativeblock(def);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void derivativeblock(Definition def) throws ParseException {
        String code;
    jj_consume_token(DERIVATIVE);
    jj_consume_token(31);
    code = codeblock();
    jj_consume_token(RBRACE);
         def.setCode(Definition.DERIV_EQUAL, trim(code));
  }

  final public void tryMFJavaBlock(Definition def) throws ParseException {
    try {
      mfjavablock(def);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void mfjavablock(Definition def) throws ParseException {
    jj_consume_token(JAVA);
    jj_consume_token(31);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
      case GREATER:
      case SMALLER:
      case CENTER:
      case BASIS:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_8;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
        tryEqualBlock(def,JAVABLOCK);
        break;
      case GREATER:
        tryGreatereqBlock(def,JAVABLOCK);
        break;
      case SMALLER:
        trySmallereqBlock(def,JAVABLOCK);
        break;
      case CENTER:
        tryCenterBlock(def,JAVABLOCK);
        break;
      case BASIS:
        tryBasisBlock(def,JAVABLOCK);
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(32);
  }

  final public void tryMFAnsiCBlock(Definition def) throws ParseException {
    try {
      mfansicblock(def);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void mfansicblock(Definition def) throws ParseException {
    jj_consume_token(ANSI_C);
    jj_consume_token(31);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
      case GREATER:
      case SMALLER:
      case CENTER:
      case BASIS:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_9;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
        tryEqualBlock(def,ANSICBLOCK);
        break;
      case GREATER:
        tryGreatereqBlock(def,ANSICBLOCK);
        break;
      case SMALLER:
        trySmallereqBlock(def,ANSICBLOCK);
        break;
      case CENTER:
        tryCenterBlock(def,ANSICBLOCK);
        break;
      case BASIS:
        tryBasisBlock(def,ANSICBLOCK);
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(32);
  }

  final public void tryMFCppBlock(Definition def) throws ParseException {
    try {
      mfcppblock(def);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void mfcppblock(Definition def) throws ParseException {
    jj_consume_token(CPLUSPLUS);
    jj_consume_token(31);
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
      case GREATER:
      case SMALLER:
      case CENTER:
      case BASIS:
        ;
        break;
      default:
        jj_la1[18] = jj_gen;
        break label_10;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
        tryEqualBlock(def,CPPBLOCK);
        break;
      case GREATER:
        tryGreatereqBlock(def,CPPBLOCK);
        break;
      case SMALLER:
        trySmallereqBlock(def,CPPBLOCK);
        break;
      case CENTER:
        tryCenterBlock(def,CPPBLOCK);
        break;
      case BASIS:
        tryBasisBlock(def,CPPBLOCK);
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(32);
  }

  final public void tryMFDerivativeBlock(Definition def) throws ParseException {
    try {
      mfderivativeblock(def);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void mfderivativeblock(Definition def) throws ParseException {
    jj_consume_token(DERIVATIVE);
    jj_consume_token(31);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
      case GREATER:
      case SMALLER:
      case CENTER:
      case BASIS:
        ;
        break;
      default:
        jj_la1[20] = jj_gen;
        break label_11;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
        tryEqualBlock(def,DERIVBLOCK);
        break;
      case GREATER:
        tryGreatereqBlock(def,DERIVBLOCK);
        break;
      case SMALLER:
        trySmallereqBlock(def,DERIVBLOCK);
        break;
      case CENTER:
        tryCenterBlock(def,DERIVBLOCK);
        break;
      case BASIS:
        tryBasisBlock(def,DERIVBLOCK);
        break;
      default:
        jj_la1[21] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(32);
  }

  final public void tryEqualBlock(Definition def, int kind) throws ParseException {
    try {
      equalblock(def,kind);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void equalblock(Definition def, int kind) throws ParseException {
         String code;
    jj_consume_token(EQUAL);
    jj_consume_token(31);
    code = codeblock();
    jj_consume_token(RBRACE);
         switch(kind) {
          case JAVABLOCK:
           def.setCode(Definition.JAVA_EQUAL, trim(code)); break;
          case DERIVBLOCK:
           def.setCode(Definition.DERIV_EQUAL, trim(code)); break;
          case ANSICBLOCK:
           def.setCode(Definition.C_EQUAL, trim(code)); break;
          case CPPBLOCK:
           def.setCode(Definition.CPP_EQUAL, trim(code)); break;
         }
  }

  final public void tryGreatereqBlock(Definition def, int kind) throws ParseException {
    try {
      greatereqblock(def,kind);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void greatereqblock(Definition def, int kind) throws ParseException {
         String code;
    jj_consume_token(GREATER);
    jj_consume_token(31);
    code = codeblock();
    jj_consume_token(RBRACE);
         switch(kind) {
          case JAVABLOCK:
           def.setCode(Definition.JAVA_GREQ, trim(code)); break;
          case DERIVBLOCK:
           def.setCode(Definition.DERIV_GREQ, trim(code)); break;
          case ANSICBLOCK:
           def.setCode(Definition.C_GREQ, trim(code)); break;
          case CPPBLOCK:
           def.setCode(Definition.CPP_GREQ, trim(code)); break;
         }
  }

  final public void trySmallereqBlock(Definition def, int kind) throws ParseException {
    try {
      smallereqblock(def,kind);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void smallereqblock(Definition def, int kind) throws ParseException {
         String code;
    jj_consume_token(SMALLER);
    jj_consume_token(31);
    code = codeblock();
    jj_consume_token(RBRACE);
         switch(kind) {
          case JAVABLOCK:
           def.setCode(Definition.JAVA_SMEQ, trim(code)); break;
          case DERIVBLOCK:
           def.setCode(Definition.DERIV_SMEQ, trim(code)); break;
          case ANSICBLOCK:
           def.setCode(Definition.C_SMEQ, trim(code)); break;
          case CPPBLOCK:
           def.setCode(Definition.CPP_SMEQ, trim(code)); break;
         }
  }

  final public void tryCenterBlock(Definition def, int kind) throws ParseException {
    try {
      centerblock(def,kind);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void centerblock(Definition def, int kind) throws ParseException {
         String code;
    jj_consume_token(CENTER);
    jj_consume_token(31);
    code = codeblock();
    jj_consume_token(RBRACE);
         switch(kind) {
          case JAVABLOCK:
           def.setCode(Definition.JAVA_CENTER, trim(code)); break;
          case DERIVBLOCK:
           def.setCode(Definition.DERIV_CENTER, trim(code)); break;
          case ANSICBLOCK:
           def.setCode(Definition.C_CENTER, trim(code)); break;
          case CPPBLOCK:
           def.setCode(Definition.CPP_CENTER, trim(code)); break;
         }
  }

  final public void tryBasisBlock(Definition def, int kind) throws ParseException {
    try {
      basisblock(def,kind);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void basisblock(Definition def, int kind) throws ParseException {
         String code;
    jj_consume_token(BASIS);
    jj_consume_token(31);
    code = codeblock();
    jj_consume_token(RBRACE);
         switch(kind) {
          case JAVABLOCK:
           def.setCode(Definition.JAVA_BASIS, trim(code)); break;
          case DERIVBLOCK:
           def.setCode(Definition.DERIV_BASIS, trim(code)); break;
          case ANSICBLOCK:
           def.setCode(Definition.C_BASIS, trim(code)); break;
          case CPPBLOCK:
           def.setCode(Definition.CPP_BASIS, trim(code)); break;
         }
  }

  void xflpackage(XflPackage pkg) throws ParseException {
 end = false;
 while(!end) {
   try { tryDefinition(pkg); }
   catch (ParseException e) { exception(e); skipto("}"); }
   catch (TokenMgrError e) { exception(e); skipto("}"); }
  }
  }

  String codeblock() throws ParseException {
 String s = "";
 int nesting = 1;
 Token t;

 token_source.curLexState = CODEBLOCK;
 while(true) {
   t = getToken(1);
   if(t.kind == LBRACE) { nesting++; s+=t.image; }
   else if(t.kind == RBRACE) {
     nesting--;
     if( nesting == 0) break;
     else s+=t.image;
    }
   else if(t.kind == EOF) break;
   else s+=t.image;
   t = getNextToken();
  }
 token_source.curLexState = DEFAULT;
 return s;
  }

  void skipto(String st) throws ParseException {
 Token t=null;
 token_source.curLexState = CODEBLOCK;
 while(true) {
   try {
    t = getNextToken();
    if(t.kind == EOF || t.image.equals(st)) break;
   } catch (TokenMgrError e) {}
  }
 token_source.curLexState = DEFAULT;
  }

  public PkgParserTokenManager token_source;
  ASCII_CharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[22];
  final private int[] jj_la1_0 = {0xf01,0x3f03000,0x3f03000,0x3f03000,0x3f03000,0x3f07000,0x3f07000,0x3f03000,0x3f03000,0x0,0x0,0xc000000,0x0,0xc000000,0xf8000,0xf8000,0xf8000,0xf8000,0xf8000,0xf8000,0xf8000,0xf8000,};
  final private int[] jj_la1_1 = {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x2,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};

  public PkgParser(java.io.InputStream stream) {
    jj_input_stream = new ASCII_CharStream(stream, 1, 1);
    token_source = new PkgParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
  }

  public PkgParser(java.io.Reader stream) {
    jj_input_stream = new ASCII_CharStream(stream, 1, 1);
    token_source = new PkgParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
  }

  public PkgParser(PkgParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
  }

  public void ReInit(PkgParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  final public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[35];
    for (int i = 0; i < 35; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 22; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 35; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
