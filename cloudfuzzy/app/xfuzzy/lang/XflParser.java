/* Generated By:JavaCC: Do not edit this line. XflParser.java */
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//		    PARSER DEL LENGUAJE XFL3			//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//

package xfuzzy.lang;

import java.io.*;
import java.util.*;

public class XflParser implements XflParserConstants {
 private String eol = System.getProperty("line.separator", "\n");
 private PkgParser pkgparser;
 private Vector imported;
 private Vector used;
 private Specification spec;

 private int error;
 private int warning;
 private String errorMsg;
 private boolean systemDefined;
 private boolean end;

 public XflParser () {
  this.pkgparser = new PkgParser();
  this.imported = new Vector();
  this.used = new Vector();
  this.error = 0;
  this.warning = 0;
  this.errorMsg = "";
  this.systemDefined = false;
 }

 public Specification parse(String filename) {
  this.imported = new Vector();
  this.used = new Vector();
  this.error = 0;
  this.warning = 0;
  this.errorMsg = "";
  this.systemDefined = false;

  File file = new File(filename);
  this.spec = new Specification(file);

  InputStream stream=null;
  try { stream = new FileInputStream(filename); }
  catch (Exception e) {

	System.out.println(">>>>>Erro no arquivo.");
   this.errorMsg += "Can't open file"+filename+eol;
   this.error ++;
   try { stream.close(); } catch (IOException ioe) {}
     
   return null;
  }

  initParse(stream);
  try { system(); }
  catch (ParseException e) {
   this.errorMsg += "Fatal error loading "+filename+eol;
   this.error ++;
   try { stream.close(); } catch (IOException ioe) {}
   return null;
  }
  catch (TokenMgrError e) {
   this.errorMsg += "Fatal error loading "+filename+eol;
   this.error ++;
   try { stream.close(); } catch (IOException ioe) {}
   return null;
  }

  try { stream.close(); } catch (IOException e) {}

  if(this.error>0) return null;
  return spec;
 }

 public String resume() {
  String msg = this.errorMsg + this.error;
  if(this.error == 1) msg += " error"; else msg += " errors";
  if(this.warning == 0) msg += ".";
  else if(this.warning == 1) msg += " and "+this.warning+" warning.";
  else msg += " and "+this.warning+" warnings.";
  return msg;
 }

 public void addXflPackagePath(File path) {
  this.pkgparser.addPath(path);
 }

 public static void main(String args[]) throws Exception {
  if(args.length != 1 && args.length != 3) return;
  XflParser parser = new XflParser();
  if(args.length == 3 && args[1].equals("-p") )
   parser.addXflPackagePath(new File(args[2]));
  Specification spec = parser.parse(args[0]);
  if(spec == null) System.out.println(parser.resume());
  else System.out.println(spec.toXfl());
 }

 private void initParse(InputStream stream) {
  jj_input_stream = new ASCII_CharStream(stream, 1, 1);
  token_source = new XflParserTokenManager(jj_input_stream);
  token = new Token();
  jj_ntk = -1;
  jj_gen = 0;
  for(int i=0; i<jj_la1.length; i++) jj_la1[i] = -1;
 }

 //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
 // 		Funciones internas de busqueda			//
 //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//

 private XflPackage searchImported(String pkgname) {
  for(int i=0, size=imported.size(); i<size; i++) {
   XflPackage pkg = (XflPackage) imported.elementAt(i);
   if(pkg.equals(pkgname)) return pkg;
  }
  return null;
 }

 private XflPackage searchXflPackage(String pkgname) {
  for(int i=0, size=imported.size(); i<size; i++) {
   XflPackage pkg = (XflPackage) imported.elementAt(i);
   if(pkg.equals(pkgname)) return pkg;
  }
  for(int i=0, size=used.size(); i<size; i++) {
   XflPackage pkg = (XflPackage) used.elementAt(i);
   if(pkg.equals(pkgname)) return pkg;
  }
  return null;
 }

 //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
 //	   Funciones internas para crear nuevos objetos		//
 //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//

 private void newImported(Token tk, String pkgname) {
  if(searchImported(pkgname)!=null) return;
  XflPackage pkgobject = pkgparser.parse(pkgname);
  if(pkgobject == null) { warning(tk,17); return; }
  imported.add(pkgobject);
 }

 private XflPackage newUsed(String pkgname) {
  XflPackage pkgobject = pkgparser.parse(pkgname);
  if(pkgobject == null) return null;
  used.add(pkgobject);
  return pkgobject;
 }

 private Operatorset newOperatorset(Token tid) {
  if(spec.searchOperatorset(tid.image)!=null) exception(tid, 9);
  Operatorset newop = new Operatorset(tid.image);
  spec.addOperatorset(newop);
  return newop;
 }

 private void newOperator(Operatorset op, Token top, Token tid, double param[]) {
  int kindop = -1;
  int kindfz = -1;
  if(top.image.equals("and"))
   { kindop = FuzzyOperator.AND; kindfz = XflPackage.BINARY; }
  if(top.image.equals("or"))
   { kindop = FuzzyOperator.OR; kindfz = XflPackage.BINARY; }
  if(top.image.equals("also"))
   { kindop = FuzzyOperator.ALSO; kindfz = XflPackage.BINARY; }
  if(top.image.equals("imp") || top.image.equals("implication"))
   { kindop = FuzzyOperator.IMP; kindfz = XflPackage.BINARY; }
  if(top.image.equals("not"))
   { kindop = FuzzyOperator.NOT; kindfz = XflPackage.UNARY; }
  if(top.image.equals("very") || top.image.equals("strongly"))
   { kindop = FuzzyOperator.VERY; kindfz = XflPackage.UNARY; }
  if(top.image.equals("moreorless"))
   { kindop = FuzzyOperator.MOREORLESS; kindfz = XflPackage.UNARY; }
  if(top.image.equals("slightly"))
   { kindop = FuzzyOperator.SLIGHTLY; kindfz = XflPackage.UNARY; }
  if(top.image.equals("defuzzification") || top.image.equals("defuz"))
   { kindop = FuzzyOperator.DEFUZMETHOD; kindfz = XflPackage.DEFUZ; }
  if(kindop == -1) { exception(top,5); return; }

  FuzzyOperator operator = null;
  int index = tid.image.indexOf('.');
  if(index == -1) {
   for(int i=0, size=imported.size(); i<size; i++) {
    XflPackage pkg = (XflPackage) imported.elementAt(i);
    if(pkg.contains(tid.image, kindfz))
     operator = (FuzzyOperator) pkg.instantiate(tid.image, kindfz);
   }
  }
  else {
   String pkgname = tid.image.substring(0,index);
   String opname = tid.image.substring(index+1);
   XflPackage pkg = searchXflPackage(pkgname);
   if(pkg==null) pkg = newUsed(pkgname);
   if(pkg==null) { exception(tid,17); exception(tid,4); return; }
   operator = (FuzzyOperator) pkg.instantiate(opname, kindfz);
  }

  if(operator==null) { exception(tid,4); return; }
  operator.set(param);
  op.set(operator, kindop);
 }

 private double[] newParameters(Token tn[],int counter) {
  double param[] = new double[counter];
  for(int i=0; i<counter; i++) param[i] = Double.parseDouble(tn[i].image);
  return param;
 }

 private Type newType(Token tid, Token tp, Universe u) {
  Type newtype = null;
  if(spec.searchType(tid.image)!=null) { exception(tid, 11); return null; }
  if(u != null) newtype = new Type(tid.image,u);
  else if(tp != null) {
   Type parent=spec.searchType(tp.image);
   if(parent == null) exception(tp,12);
   else newtype = new Type(tid.image,parent);
  }
  if(newtype==null) newtype = new Type(tid.image);
  spec.addType(newtype);
  return newtype;
 }

 private Universe newUniverse(Token tmin, Token tmax, Token tcard) {
  double min = Double.valueOf(tmin.image).doubleValue();
  double max = Double.valueOf(tmax.image).doubleValue();
  if(tcard == null)
   try { return new Universe(min,max); }
   catch (XflException e) { exception(tmin, e); return null; }

  try {
   int card = Integer.parseInt(tcard.image);
   return new Universe(min,max,card);
  }
  catch (XflException e) { exception(tmin, e); return null; }
  catch (NumberFormatException e) { exception(tmin, 2); return null; }
 }

 private void newMemFunc(Type type, Token tmf, Token tid, double param[]) {
  if(type == null) return;
  ParamMemFunc mf = null;
  int index = tid.image.indexOf('.');
  if(index == -1) {
   for(int i=0, size=imported.size(); i<size; i++) {
    XflPackage pkg = (XflPackage) imported.elementAt(i);
    if(pkg.contains(tid.image, XflPackage.MFUNC))
     mf = (ParamMemFunc) pkg.instantiate(tid.image, XflPackage.MFUNC);
   }
  }
  else {
   String pkgname = tid.image.substring(0,index);
   String mfname = tid.image.substring(index+1);
   XflPackage pkg = searchXflPackage(pkgname);
   if(pkg==null) pkg = newUsed(pkgname);
   if(pkg==null) { exception(tid,17); exception(tid,4); return; }
   mf = (ParamMemFunc) pkg.instantiate(mfname, XflPackage.MFUNC);
  }

  if(mf==null) { exception(tid,7); return; }

  try {
   mf.set(tmf.image, type.getUniverse());
   mf.set(param);
   type.add(mf);
  }
  catch (XflException e) { exception(tmf, e); }
 }

 private Rulebase newRulebase(Token tmod) {
  if(spec.searchRulebase(tmod.image)!=null) {exception(tmod,13); return null; }
  Rulebase newmod = new Rulebase(tmod.image);
  spec.addRulebase(newmod);
  return newmod;
 }

 private void newVariable(Rulebase mod, Token ttype, Token tvar, boolean input) {
  if(mod == null) return;
  Type type = spec.searchType(ttype.image);
  if(type == null) { exception(ttype,12); return; }
  if(mod.searchVariable(tvar.image) != null ) { exception(tvar,15); return; }
  if(input) {
   Variable inputvar = new Variable(tvar.image,type,Variable.INPUT);
   mod.addInputVariable(inputvar);
  }
  else {
   Variable outputvar = new Variable(tvar.image,type,mod);
   mod.addOutputVariable(outputvar);
  }
 }

 private void newUsingOp(Rulebase mod, Token top) {
  if(mod == null) return;

  if(top == null) {
   Operatorset op = spec.searchOperatorset("_default_");
   if(op == null) { op = new Operatorset(); spec.addOperatorset(op); }
   mod.setOperatorset(op);
   return;
  }

  Operatorset op = spec.searchOperatorset(top.image);
  if(op==null) exception(top,10);
  else mod.setOperatorset(op);
 }

 private Rule newRule(Relation rel, Rulebase mod, Token tdg) {
  Rule rule;
  if(tdg == null) rule = new Rule(rel);
  else {
   double degree = Double.parseDouble(tdg.image);
   rule = new Rule(rel,degree);
  }
  mod.addRule(rule);
  return rule;
 }

 private Relation newProposition(Token tvar,Token tmf,Rulebase mod,int code) {
  Variable var = mod.searchVariable(tvar.image);
  if(var == null) { exception(tvar, 16); return null; }

  ParamMemFunc mf = var.search(tmf.image);
  if(mf == null) { exception(tvar, 6); return null; }

  switch (code) {
   case 0: return Relation.create(Relation.IS,null,null,var,mf,mod);
   case 1: return Relation.create(Relation.ISNOT,null,null,var,mf,mod);
   case 2: return Relation.create(Relation.GR_EQ,null,null,var,mf,mod);
   case 3: return Relation.create(Relation.SM_EQ,null,null,var,mf,mod);
   case 4: return Relation.create(Relation.GREATER,null,null,var,mf,mod);
   case 5: return Relation.create(Relation.SMALLER,null,null,var,mf,mod);
   case 6: return Relation.create(Relation.APP_EQ,null,null,var,mf,mod);
   case 7: return Relation.create(Relation.VERY_EQ,null,null,var,mf,mod);
   case 8: return Relation.create(Relation.SL_EQ,null,null,var,mf,mod);
   default: return null;
  }
 }

 private void newConclusion(Token tvar, Token tmf, Rulebase mod, Rule rule) {
  if(rule == null) return;
  Variable output = mod.searchVariable(tvar.image);
  if(output==null) { exception(tvar,16); return; }
  ParamMemFunc mf = output.search(tmf.image);
  if(mf==null) { exception(tmf,6); return; }
  rule.add(new Conclusion(output,mf,mod));
 }

 private void newSystemModule(Token t) {
  if(systemDefined) { exception(t,24); return; }
  systemDefined = true;
 }

 private void newVariable(Token ttype, Token tid, boolean input) {
  Type type = spec.searchType(ttype.image);
  if(type == null) { exception(ttype,12); return; }
  if(spec.getSystemModule().searchVariable(tid.image) != null )
   { exception(tid,15); return; }
  if(input) {
   Variable inputvar = new Variable(tid.image,type,Variable.INPUT);
   spec.getSystemModule().addVariable(inputvar);
  }
  else {
   Variable outputvar = new Variable(tid.image,type,Variable.OUTPUT);
   spec.getSystemModule().addVariable(outputvar);
  }
 }

 private void newCall(Token t, Vector iv, Vector ov) {
  Rulebase ref = spec.searchRulebase(t.image);
  if(ref == null) { exception(t,20); return; }
  if(ref.getInputs().length != iv.size()) { exception(t,21); return; }
  if(ref.getOutputs().length != ov.size()) { exception(t,21); return; }
  Variable[] ivar = new Variable[iv.size()];
  Variable[] ovar = new Variable[ov.size()];
  for(int i=0; i<ivar.length; i++) {
   String varname = (String) iv.elementAt(i);
   ivar[i] = spec.getSystemModule().searchVariable( varname );
   if(ivar[i] == null) { exception(t,22); return; }
  }
  for(int i=0; i<ovar.length; i++) {
   String varname = (String) ov.elementAt(i);
   ovar[i] = spec.getSystemModule().searchVariable( varname );
   if(ovar[i] != null && !ovar[i].isOutput()) { exception(t,23); return; }
   if(ovar[i] == null) {
    ovar[i] = new Variable(varname,Variable.INNER);
    spec.getSystemModule().addVariable(ovar[i]);
   }
  }
  spec.getSystemModule().addCall(ref,ivar,ovar);
 }

 //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
 //		Funciones de manejo de excepciones		//
 //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//

 private void exception(Token t, XflException e) {
  this.error ++;
  this.errorMsg += "Xfuzzy ["+this.error+"]. ";
  this.errorMsg += "Parse error at line "+t.beginLine+" : "+e+eol;
 }

 private void exception(Token t, int code) {
  this.error ++;
  this.errorMsg += "Xfuzzy ["+this.error+"]. ";
  this.errorMsg += "Parse error at line "+t.beginLine+" : ";
  this.errorMsg += XflException.getMessage(code)+eol;
 }

 private void exception(ParseException e) {
  Token t = e.currentToken.next;
  this.error ++;
  this.errorMsg += "Xfuzzy ["+this.error+"]. ";
  this.errorMsg += "Parse error at line "+t.beginLine+" : ";
  this.errorMsg += "Encountered \""+t.image+"\""+" while expecting ";

  int expected[] = new int[e.expectedTokenSequences.length];
  for(int i=0; i<expected.length; i++)
   expected[i] = e.expectedTokenSequences[i][0];
  if(expected.length == 1) this.errorMsg += e.tokenImage[expected[0]]+"."+eol;
  else {
   this.errorMsg += "one of :"+e.tokenImage[expected[0]];
   for(int i=1; i<expected.length; i++)
    this.errorMsg += ", "+e.tokenImage[expected[i]];
   this.errorMsg += "."+eol;
  }
 }

 private void exception(TokenMgrError e) {
  this.error ++;
  this.errorMsg += "Xfuzzy ["+this.error+"]. "+e.getMessage()+eol;
 }

 private void warning(Token t, int code) {
  this.warning++;
  if(t==null) this.errorMsg += "Warning : ";
  else this.errorMsg += "Warning at line "+t.beginLine+" : ";
  this.errorMsg += XflException.getMessage(code)+eol;
 }

  final public void system() throws ParseException {
        end = false;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPORT:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      tryImportXflPackage();
    }
         newImported(null,"xfl");
    tryDefinitions();
  }

  final public void tryImportXflPackage() throws ParseException {
    try {
      importXflPackage();
    } catch (ParseException e) {
                            exception(e); skipto(";");
    } catch (TokenMgrError e) {
                           exception(e); skipto(";");
    }
  }

  final public void importXflPackage() throws ParseException {
        Token tid;
    jj_consume_token(IMPORT);
    tid = jj_consume_token(ID);
    jj_consume_token(37);
         newImported(tid, tid.image);
  }

  final public void definition() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPERATORSET:
      tryOperatorset();
      break;
    case TYPE:
      tryType();
      break;
    case RULEBASE:
      tryRulebase();
      break;
    case SYSTEM:
      trySystemModule();
      break;
    case 0:
      jj_consume_token(0);
           end = true;
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void tryOperatorset() throws ParseException {
    try {
      operatorset();
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void operatorset() throws ParseException {
        Token tid;
        Operatorset newop;
    jj_consume_token(OPERATORSET);
    tid = jj_consume_token(ID);
         newop = newOperatorset(tid);
    jj_consume_token(38);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
      tryOperator(newop);
    }
    jj_consume_token(39);
  }

  final public void tryOperator(Operatorset op) throws ParseException {
    try {
      operator(op);
    } catch (ParseException e) {
                            exception(e); skipto(";");
    } catch (TokenMgrError e) {
                           exception(e); skipto(";");
    }
  }

  final public void operator(Operatorset op) throws ParseException {
        Token top;
        Token tname;
        double param[];
    top = jj_consume_token(ID);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPERATOR:
      tname = jj_consume_token(OPERATOR);
      break;
    case ID:
      tname = jj_consume_token(ID);
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    param = tryParameters();
    jj_consume_token(37);
         newOperator(op,top,tname,param);
  }

  final public double[] tryParameters() throws ParseException {
        double param[];
    try {
      param = parameters();
                           {if (true) return param;}
    } catch (ParseException e) {
                            exception(e); skipto(")"); {if (true) return new double[0];}
    } catch (TokenMgrError e) {
                           exception(e); skipto(")"); {if (true) return new double[0];}
    }
    throw new Error("Missing return statement in function");
  }

  final public double[] parameters() throws ParseException {
        Token tn[] = new Token[25];
        int i=0;
    jj_consume_token(40);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMBER:
      tn[i] = jj_consume_token(NUMBER);
                        i++;
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 41:
          ;
          break;
        default:
          jj_la1[4] = jj_gen;
          break label_3;
        }
        jj_consume_token(41);
        tn[i] = jj_consume_token(NUMBER);
                                                    i++;
      }
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    jj_consume_token(42);
         {if (true) return newParameters(tn,i);}
    throw new Error("Missing return statement in function");
  }

  final public void tryType() throws ParseException {
    try {
      type();
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void type() throws ParseException {
        Token tid;
        Token tp = null;
        Universe u = null;
        Type newtype;
    jj_consume_token(TYPE);
    tid = jj_consume_token(ID);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTENDS:
    case 43:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 43:
        u = universe();
        break;
      case EXTENDS:
        jj_consume_token(EXTENDS);
        tp = jj_consume_token(ID);
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
         newtype = newType(tid,tp,u);
    jj_consume_token(38);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_4;
      }
      tryMemFunc(newtype);
    }
    jj_consume_token(39);
  }

  final public Universe tryUniverse() throws ParseException {
        Universe u = null;
    try {
      u = universe();
                     {if (true) return u;}
    } catch (ParseException e) {
                            exception(e); skipto("]"); {if (true) return u;}
    } catch (TokenMgrError e) {
                           exception(e); skipto("]"); {if (true) return u;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Universe universe() throws ParseException {
        Token tmin;
        Token tmax;
        Token tcard=null;
    jj_consume_token(43);
    tmin = jj_consume_token(NUMBER);
    jj_consume_token(41);
    tmax = jj_consume_token(NUMBER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 37:
      jj_consume_token(37);
      tcard = jj_consume_token(NUMBER);
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
    jj_consume_token(44);
         {if (true) return newUniverse(tmin,tmax,tcard);}
    throw new Error("Missing return statement in function");
  }

  final public void tryMemFunc(Type type) throws ParseException {
    try {
      memfunc(type);
    } catch (ParseException e) {
                            exception(e); skipto(";");
    } catch (TokenMgrError e) {
                           exception(e); skipto(";");
    }
  }

  final public void memfunc(Type type) throws ParseException {
        Token tmf;
        Token tname;
        double param[];
    tname = jj_consume_token(ID);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPERATOR:
      tmf = jj_consume_token(OPERATOR);
      break;
    case ID:
      tmf = jj_consume_token(ID);
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    param = tryParameters();
    jj_consume_token(37);
         newMemFunc(type,tname,tmf,param);
  }

  final public void tryRulebase() throws ParseException {
    try {
      rulebase();
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void rulebase() throws ParseException {
        Token tmod;
        Token top;
        Rulebase newmod;
    jj_consume_token(RULEBASE);
    tmod = jj_consume_token(ID);
                        newmod = newRulebase(tmod);
    tryVariables(newmod);
    tryUsingOp(newmod);
    label_5:
    while (true) {
      rule(newmod);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
      case 43:
        ;
        break;
      default:
        jj_la1[11] = jj_gen;
        break label_5;
      }
    }
    jj_consume_token(39);
  }

  final public void tryVariables(Rulebase mod) throws ParseException {
    try {
      variables(mod);
    } catch (ParseException e) {
                            exception(e); skipto(")");
    } catch (TokenMgrError e) {
                           exception(e); skipto(")");
    }
  }

  final public void variables(Rulebase mod) throws ParseException {
    jj_consume_token(40);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      variable(mod,true);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 41:
          ;
          break;
        default:
          jj_la1[12] = jj_gen;
          break label_6;
        }
        jj_consume_token(41);
        variable(mod, true);
      }
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
    jj_consume_token(45);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      variable(mod,false);
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 41:
          ;
          break;
        default:
          jj_la1[14] = jj_gen;
          break label_7;
        }
        jj_consume_token(41);
        variable(mod, false);
      }
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    jj_consume_token(42);
  }

  final public void variable(Rulebase mod, boolean input) throws ParseException {
        Token ttype;
        Token tvar;
    ttype = jj_consume_token(ID);
    tvar = jj_consume_token(ID);
         newVariable(mod,ttype,tvar,input);
  }

  final public void tryUsingOp(Rulebase mod) throws ParseException {
    try {
      usingop(mod);
    } catch (ParseException e) {
                            exception(e); skipto("{");
    } catch (TokenMgrError e) {
                           exception(e); skipto("{");
    }
  }

  final public void usingop(Rulebase mod) throws ParseException {
        Token top = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case USING:
      jj_consume_token(USING);
      top = jj_consume_token(ID);
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    jj_consume_token(38);
         newUsingOp(mod,top);
  }

  final public void tryRule(Rulebase mod) throws ParseException {
    try {
      rule(mod);
    } catch (ParseException e) {
                            exception(e); skipto(";");
    } catch (TokenMgrError e) {
                           exception(e); skipto(";");
    }
  }

  final public void rule(Rulebase mod) throws ParseException {
        Rule rule;
        Token tdg = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 43:
      jj_consume_token(43);
      tdg = jj_consume_token(NUMBER);
      jj_consume_token(44);
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    jj_consume_token(IF);
    rule = tryAntecedent(mod, tdg);
    jj_consume_token(THEN);
    tryConclusions(mod, rule);
  }

  final public Rule tryAntecedent(Rulebase mod, Token tdg) throws ParseException {
        Rule rule;
    try {
      rule = antecedent(mod,tdg);
                                    {if (true) return rule;}
    } catch (ParseException e) {
                            exception(e); skipto(")"); {if (true) return null;}
    } catch (TokenMgrError e) {
                           exception(e); skipto(")"); {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Rule antecedent(Rulebase mod, Token tdg) throws ParseException {
        Relation rel;
    jj_consume_token(40);
    rel = relation(mod);
    jj_consume_token(42);
         {if (true) return newRule(rel,mod,tdg);}
    throw new Error("Missing return statement in function");
  }

  final public Relation relation(Rulebase mod) throws ParseException {
        Relation rel;
        Relation lrel;
        Relation rrel;
    rel = unary(mod);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
      case OR:
        ;
        break;
      default:
        jj_la1[18] = jj_gen;
        break label_8;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        jj_consume_token(AND);
        rrel = unary(mod);
         lrel = rel;
         rel = Relation.create(Relation.AND,lrel,rrel,null,null,mod);
        break;
      case OR:
        jj_consume_token(OR);
        rrel = unary(mod);
         lrel = rel;
         rel = Relation.create(Relation.OR,lrel,rrel,null,null,mod);
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
         {if (true) return rel;}
    throw new Error("Missing return statement in function");
  }

  final public Relation unary(Rulebase mod) throws ParseException {
        Relation prop;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
    case 40:
      prop = proposition(mod);
         {if (true) return prop;}
      break;
    case NOT:
      jj_consume_token(NOT);
      prop = proposition(mod);
         {if (true) return Relation.create(Relation.NOT,prop,null,null,null,mod);}
      break;
    case VERY:
      jj_consume_token(VERY);
      prop = proposition(mod);
         {if (true) return Relation.create(Relation.VERY,prop,null,null,null,mod);}
      break;
    case MOREORLESS:
      jj_consume_token(MOREORLESS);
      prop = proposition(mod);
         {if (true) return Relation.create(Relation.MoL,prop,null,null,null,mod);}
      break;
    case SLIGHTLY:
      jj_consume_token(SLIGHTLY);
      prop = proposition(mod);
         {if (true) return Relation.create(Relation.SLIGHTLY,prop,null,null,null,mod);}
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Relation proposition(Rulebase mod) throws ParseException {
        Token tvar;
        Token tmf;
        Relation prop;
        int code;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      prop = simpleProposition(mod);
      break;
    case 40:
      prop = tryCompound(mod);
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
         {if (true) return prop;}
    throw new Error("Missing return statement in function");
  }

  final public Relation simpleProposition(Rulebase mod) throws ParseException {
        Token tvar;
        Token tmf;
        int code;
    tvar = jj_consume_token(ID);
    code = comparative();
    tmf = jj_consume_token(ID);
         {if (true) return newProposition(tvar,tmf,mod,code);}
    throw new Error("Missing return statement in function");
  }

  final public int comparative() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IS:
      jj_consume_token(IS);
          {if (true) return 0;}
      break;
    case ISNOT:
      jj_consume_token(ISNOT);
             {if (true) return 1;}
      break;
    case GREATEROREQUAL:
      jj_consume_token(GREATEROREQUAL);
                      {if (true) return 2;}
      break;
    case SMALLEROREQUAL:
      jj_consume_token(SMALLEROREQUAL);
                      {if (true) return 3;}
      break;
    case GREATER:
      jj_consume_token(GREATER);
               {if (true) return 4;}
      break;
    case SMALLER:
      jj_consume_token(SMALLER);
               {if (true) return 5;}
      break;
    case APPROXEQUAL:
      jj_consume_token(APPROXEQUAL);
                   {if (true) return 6;}
      break;
    case VERYEQUAL:
      jj_consume_token(VERYEQUAL);
                 {if (true) return 7;}
      break;
    case SLIGHTLYEQUAL:
      jj_consume_token(SLIGHTLYEQUAL);
                     {if (true) return 8;}
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Relation tryCompound(Rulebase mod) throws ParseException {
        Relation prop;
    try {
      prop = compoundProposition(mod);
                                         {if (true) return prop;}
    } catch (ParseException e) {
                            exception(e); skipto(")"); {if (true) return null;}
    } catch (TokenMgrError e) {
                           exception(e); skipto(")"); {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Relation compoundProposition(Rulebase mod) throws ParseException {
        Relation prop;
    jj_consume_token(40);
    prop = relation(mod);
    jj_consume_token(42);
         {if (true) return prop;}
    throw new Error("Missing return statement in function");
  }

  final public void tryConclusions(Rulebase mod, Rule rule) throws ParseException {
    try {
      conclusions(mod,rule);
    } catch (ParseException e) {
                            exception(e); skipto(";");
    } catch (TokenMgrError e) {
                           exception(e); skipto(";");
    }
  }

  final public void conclusions(Rulebase mod, Rule rule) throws ParseException {
        Token tvar;
        Token tmf;
    conclusion(mod,rule);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 41:
        ;
        break;
      default:
        jj_la1[23] = jj_gen;
        break label_9;
      }
      jj_consume_token(41);
      conclusion(mod,rule);
    }
    jj_consume_token(37);
  }

  final public void conclusion(Rulebase mod, Rule rule) throws ParseException {
        Token tvar;
        Token tmf;
    tvar = jj_consume_token(ID);
    jj_consume_token(ASIGN);
    tmf = jj_consume_token(ID);
         newConclusion(tvar,tmf,mod,rule);
  }

  final public void trySystemModule() throws ParseException {
    try {
      systemmod();
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void systemmod() throws ParseException {
        Token t;
    t = jj_consume_token(SYSTEM);
         newSystemModule(t);
    jj_consume_token(40);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      systemvar(true);
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 41:
          ;
          break;
        default:
          jj_la1[24] = jj_gen;
          break label_10;
        }
        jj_consume_token(41);
        systemvar(true);
      }
      break;
    default:
      jj_la1[25] = jj_gen;
      ;
    }
    jj_consume_token(45);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      systemvar(false);
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 41:
          ;
          break;
        default:
          jj_la1[26] = jj_gen;
          break label_11;
        }
        jj_consume_token(41);
        systemvar(false);
      }
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
    jj_consume_token(42);
    jj_consume_token(38);
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        ;
        break;
      default:
        jj_la1[28] = jj_gen;
        break label_12;
      }
      tryCall();
    }
    jj_consume_token(39);
  }

  final public void systemvar(boolean input) throws ParseException {
        Token ttype;
        Token tid;
    ttype = jj_consume_token(ID);
    tid = jj_consume_token(ID);
         newVariable(ttype,tid,input);
  }

  final public void tryCall() throws ParseException {
    try {
      call();
    } catch (ParseException e) {
                            exception(e); skipto(";");
    } catch (TokenMgrError e) {
                           exception(e); skipto(";");
    }
  }

  final public void call() throws ParseException {
        Token tmod;
        Token tvar;
        Vector iv = new Vector();
        Vector ov = new Vector();
    tmod = jj_consume_token(ID);
    jj_consume_token(40);
    tvar = jj_consume_token(ID);
                   iv.add(tvar.image);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 41:
        ;
        break;
      default:
        jj_la1[29] = jj_gen;
        break label_13;
      }
      jj_consume_token(41);
      tvar = jj_consume_token(ID);
                        iv.add(tvar.image);
    }
    jj_consume_token(45);
    tvar = jj_consume_token(ID);
                   ov.add(tvar.image);
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 41:
        ;
        break;
      default:
        jj_la1[30] = jj_gen;
        break label_14;
      }
      jj_consume_token(41);
      tvar = jj_consume_token(ID);
                        ov.add(tvar.image);
    }
    jj_consume_token(42);
    jj_consume_token(37);
           newCall(tmod,iv,ov);
  }

  void tryDefinitions() throws ParseException {
 while(!end) {
  try { definition(); }
  catch (ParseException e) { exception(e); skipto("}"); }
  catch (TokenMgrError e) { exception(e); end = true; }
 }
  }

  void skipto(String st) throws ParseException {
 Token t;
 do { t = getNextToken();}
 while(t.kind != EOF && !t.image.equals(st));
  }

  public XflParserTokenManager token_source;
  ASCII_CharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[31];
  final private int[] jj_la1_0 = {0x80,0x4b01,0x0,0x0,0x0,0x0,0x400,0x400,0x0,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x1000,0x0,0x18000,0x18000,0x1e0000,0x0,0x3fe00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
  final private int[] jj_la1_1 = {0x0,0x0,0x1,0x3,0x200,0x4,0x800,0x800,0x1,0x20,0x3,0x800,0x200,0x1,0x200,0x1,0x0,0x800,0x0,0x0,0x101,0x101,0x0,0x200,0x200,0x1,0x200,0x1,0x1,0x200,0x200,};

  public XflParser(java.io.InputStream stream) {
    jj_input_stream = new ASCII_CharStream(stream, 1, 1);
    token_source = new XflParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
  }

  public XflParser(java.io.Reader stream) {
    jj_input_stream = new ASCII_CharStream(stream, 1, 1);
    token_source = new XflParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
  }

  public XflParser(XflParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
  }

  public void ReInit(XflParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  final public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[46];
    for (int i = 0; i < 46; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 31; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 46; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
